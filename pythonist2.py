from loguru import logger

#  https://t.me/pyway/271

"""
Есть обманка: При оформлении функции, возвращающие коллекции, 
как генераторы с ключевым словом yield. Вот так:
"""


def make_adders1():
    for a in range(3):
        def adder(x):
            return a + x

        yield adder


"""
Видите, тут нет фикса a=a из поста выше (https://t.me/pyway/270)! Казалось бы, что код должен также содержать в себе 
баг и выводить "4 4 4", но он работает, как задумано изначально:
"""


def primer1():
    logger.info(f"")
    adders = make_adders1()
    for adder in adders:
        logger.info(adder(2))  # 2 3 4


"""
Однако, если мы применим list к генератору, извлекая все значения разом, то баг вернется:
"""


def primer2():
    logger.info(f"")

    adders = list(make_adders1())
    for adder in adders:
        logger.info(adder(2))  # 4 4 4


"""
Разгадка. В первом случае происходят следующие действия:
⋅ a = 0
⋅ yield функцию (a + x), make_adders становится на паузу
⋅ печать adder(2) = 0 + 2 = 2
⋅ make_adders запускается
⋅ a = 1
⋅ yield функцию (a + x), пауза
⋅ печать adder(2) = 1 + 2 = 2

И так далее. То есть мы запускаем adder только один раз в тот момент, пока переменная a еще равна нужному значению. 

Во втором код list прокручивает make_adders до конца, оставляя a = 2, и все функции выдают одинаковый результат.

Вывод мы должны сделать такой: yield не создает нового замыкания с отдельной переменной a и не освобождает нас от 
ответственности следить за переменными.

Еще кое-что. 
"""


def primer3():
    logger.info(f"")

    adders = make_adders1()
    for adder in adders:
        logger.info(adder(2))  # 2 3 4

"""
После исполнения цикла в коде выше, генератор adders будет исчерпан. В нем больше не останется значений, и если еще раз
 запустить цикл по adders, то он пройдет ровно 0 итераций. 

next(adders)  # StopIteration

Генератор – вещь одноразовая.
"""

def primer():
    primer1()
    primer2()
    primer3()
